---
layout: post
title: Lab 07 Writing Assembly on Raspberry Pi Using QEMU
date: 2023-09-01 00:00:00
---
<!-- more -->
##### This lab is mainly from the [QEMU Web](https://www.qemu.org/) and [Azeria Labs](https://azeria-labs.com/emulate-raspberry-pi-with-qemu/)

Before we can start diving into ARM exploit development we first need to understand the basics of Assembly language programming, which requires a little background knowledge before you can start to appreciate it. But why do we even need ARM Assembly, isn’t it enough to write our exploits in a “normal” programming / scripting language? It is not, if we want to be able to do Reverse Engineering and understand the program flow of ARM binaries, build our own ARM shellcode, craft ARM ROP chains, and debug ARM applications.

You don’t need to know every little detail of the Assembly language to be able to do Reverse Engineering and exploit development, yet some of it is required for understanding the bigger picture. The fundamentals will be covered in this tutorial series. If you want to learn more you can visit the links listed at the end of this chapter.

So what exactly is Assembly language? Assembly language is just a thin syntax layer on top of the machine code which is composed of instructions, that are encoded in binary representations (machine code), which is what our computer understands. So why don’t we just write machine code instead? Well, that would be a pain in the ass. For this reason, we will write assembly, ARM assembly, which is much easier for humans to understand. Our computer can’t run assembly code itself, because it needs machine code. The tool we will use to assemble the assembly code into machine code is a GNU Assembler from the [GNU Binutils](https://www.gnu.org/software/binutils/) project named *as* which works with source files having the `*.s` extension.

Once you wrote your assembly file with the extension `*.s`, you need to assemble it with [as](https://sourceware.org/binutils/docs/as/index.html#Top) and link it with [ld](https://sourceware.org/binutils/docs/ld/):

```shell
$ as program.s -o program.o
$ ld program.o -o program
```
![]({{ site.baseurl }}/public/images/gif-assembly-to-machine-code.gif)


```nasm
.org 0x1000  // Start at memory location 1000
.text        // Code section
.global _start
_start:

mov r4, #77
mov r5, #88
mOV R6, #99

again: 
mov r7, r4
add r4, r6, r4
mov r5, r7
subs r6, r6, #1
bne again

_stop:
b _stop

```

Task: 
-----------

* * *
